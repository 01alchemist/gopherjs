diff -r 181facb811b3 go/types/call.go
--- a/go/types/call.go	Fri Oct 11 14:27:44 2013 -0700
+++ b/go/types/call.go	Sat Oct 12 19:10:17 2013 +0200
@@ -246,7 +246,6 @@
 }
 
 func (check *checker) selector(x *operand, e *ast.SelectorExpr) {
-	// these must be declared before the "goto Error" statements
 	var (
 		obj      Object
 		index    []int
@@ -267,7 +266,9 @@
 				if !pkg.pkg.fake {
 					check.errorf(e.Pos(), "%s not declared by package %s", sel, ident)
 				}
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return
 			}
 			if !exp.IsExported() {
 				check.errorf(e.Pos(), "%s not exported by package %s", sel, ident)
@@ -306,7 +307,9 @@
 
 	check.exprOrType(x, e.X)
 	if x.mode == invalid {
-		goto Error
+		x.mode = invalid
+		x.expr = e
+		return
 	}
 
 	obj, index, indirect = LookupFieldOrMethod(x.typ, check.pkg, sel)
@@ -317,7 +320,9 @@
 		} else {
 			check.invalidOp(e.Pos(), "%s has no field or method %s", x, sel)
 		}
-		goto Error
+		x.mode = invalid
+		x.expr = e
+		return
 	}
 
 	if x.mode == typexpr {
@@ -325,13 +330,17 @@
 		m, _ := obj.(*Func)
 		if m == nil {
 			check.invalidOp(e.Pos(), "%s has no method %s", x, sel)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return
 		}
 
 		// verify that m is in the method set of x.typ
 		if !indirect && ptrRecv(m) {
 			check.invalidOp(e.Pos(), "%s is not in method set of %s", sel, x.typ)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return
 		}
 
 		check.recordSelection(e, MethodExpr, x.typ, m, index, indirect)
@@ -372,7 +381,9 @@
 			//        is shorthand for (&x).m()".
 			if !indirect && x.mode != variable && ptrRecv(obj) {
 				check.invalidOp(e.Pos(), "%s is not in method set of %s", sel, x)
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return
 			}
 
 			check.recordSelection(e, MethodVal, x.typ, obj, index, indirect)
@@ -420,9 +431,4 @@
 
 	// everything went well
 	x.expr = e
-	return
-
-Error:
-	x.mode = invalid
-	x.expr = e
 }
diff -r 181facb811b3 go/types/expr.go
--- a/go/types/expr.go	Fri Oct 11 14:27:44 2013 -0700
+++ b/go/types/expr.go	Sat Oct 12 19:10:17 2013 +0200
@@ -481,7 +481,9 @@
 				check.updateExprType(x.expr, target, false)
 			}
 		} else if xkind != tkind {
-			goto Error
+			check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+			x.mode = invalid
+			return
 		}
 		return
 	}
@@ -502,11 +504,15 @@
 			switch x.typ.(*Basic).kind {
 			case UntypedBool:
 				if !isBoolean(target) {
-					goto Error
+					check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+					x.mode = invalid
+					return
 				}
 			case UntypedInt, UntypedRune, UntypedFloat, UntypedComplex:
 				if !isNumeric(target) {
-					goto Error
+					check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+					x.mode = invalid
+					return
 				}
 			case UntypedString:
 				// Non-constant untyped string values are not
@@ -515,15 +521,21 @@
 			case UntypedNil:
 				// Unsafe.Pointer is a basic type that includes nil.
 				if !hasNil(target) {
-					goto Error
+					check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+					x.mode = invalid
+					return
 				}
 			default:
-				goto Error
+				check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+				x.mode = invalid
+				return
 			}
 		}
 	case *Interface:
 		if !x.isNil() && t.NumMethods() > 0 /* empty interfaces are ok */ {
-			goto Error
+			check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+			x.mode = invalid
+			return
 		}
 		// Update operand types to the default type rather then
 		// the target (interface) type: values must have concrete
@@ -536,27 +548,28 @@
 		} else {
 			// cannot assign untyped values to non-empty interfaces
 			if t.NumMethods() > 0 {
-				goto Error
+				check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+				x.mode = invalid
+				return
 			}
 			target = defaultType(x.typ)
 		}
 	case *Pointer, *Signature, *Slice, *Map, *Chan:
 		if !x.isNil() {
-			goto Error
+			check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+			x.mode = invalid
+			return
 		}
 		// keep nil untyped - see comment for interfaces, above
 		target = Typ[UntypedNil]
 	default:
-		goto Error
+		check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+		x.mode = invalid
+		return
 	}
 
 	x.typ = target
 	check.updateExprType(x.expr, target, true) // UntypedNils are final
-	return
-
-Error:
-	check.errorf(x.pos(), "cannot convert %s to %s", x, target)
-	x.mode = invalid
 }
 
 func (check *checker) comparison(x, y *operand, op token.Token) {
@@ -753,9 +766,12 @@
 	}
 
 	if (op == token.QUO || op == token.REM) && y.mode == constant && exact.Sign(y.val) == 0 {
-		check.invalidOp(y.pos(), "division by zero")
-		x.mode = invalid
-		return
+		if !isFloat(x.typ) {
+			check.invalidOp(y.pos(), "division by zero")
+			x.mode = invalid
+			return
+		}
+		x.mode = value
 	}
 
 	if x.mode == constant && y.mode == constant {
@@ -898,7 +914,7 @@
 		typ = Typ[Invalid]
 		record = false // nothing to do
 	case novalue:
-		typ = (*Tuple)(nil)
+		typ = (*Tuple)(NewTuple())
 	case constant:
 		typ = x.typ
 		val = x.val
@@ -937,7 +953,9 @@
 
 	switch e := e.(type) {
 	case *ast.BadExpr:
-		goto Error // error was reported before
+		x.mode = invalid
+		x.expr = e
+		return statement // error was reported before
 
 	case *ast.Ident:
 		check.ident(x, e, nil, false)
@@ -946,13 +964,17 @@
 		// ellipses are handled explicitly where they are legal
 		// (array composite literals and parameter lists)
 		check.errorf(e.Pos(), "invalid use of '...'")
-		goto Error
+		x.mode = invalid
+		x.expr = e
+		return statement
 
 	case *ast.BasicLit:
 		x.setConst(e.Kind, e.Value)
 		if x.mode == invalid {
 			check.invalidAST(e.Pos(), "invalid literal %v", e.Value)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 	case *ast.FuncLit:
@@ -962,7 +984,9 @@
 			check.later(nil, sig, e.Body)
 		} else {
 			check.invalidAST(e.Pos(), "invalid function literal %s", e)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 	case *ast.CompositeLit:
@@ -987,7 +1011,9 @@
 		}
 		if typ == nil {
 			check.errorf(e.Pos(), "missing type in composite literal")
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		switch typ, _ := deref(typ); utyp := typ.Underlying().(type) {
@@ -1102,7 +1128,9 @@
 
 		default:
 			check.errorf(e.Pos(), "invalid composite literal type %s", typ)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		x.mode = value
@@ -1119,7 +1147,9 @@
 	case *ast.IndexExpr:
 		check.expr(x, e.X)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		valid := false
@@ -1166,7 +1196,9 @@
 				if key.mode != invalid {
 					check.invalidOp(key.pos(), "cannot use %s as map index of type %s", &key, typ.key)
 				}
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return statement
 			}
 			x.mode = mapindex
 			x.typ = typ.elt
@@ -1176,12 +1208,16 @@
 
 		if !valid {
 			check.invalidOp(x.pos(), "cannot index %s", x)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		if e.Index == nil {
 			check.invalidAST(e.Pos(), "missing index for %s", x)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		check.index(e.Index, length)
@@ -1190,7 +1226,9 @@
 	case *ast.SliceExpr:
 		check.expr(x, e.X)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		valid := false
@@ -1200,7 +1238,9 @@
 			if isString(typ) {
 				if slice3(e) {
 					check.invalidOp(x.pos(), "3-index slice of string")
-					goto Error
+					x.mode = invalid
+					x.expr = e
+					return statement
 				}
 				valid = true
 				if x.mode == constant {
@@ -1219,7 +1259,9 @@
 			length = typ.len
 			if x.mode != variable {
 				check.invalidOp(x.pos(), "cannot slice %s (value not addressable)", x)
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return statement
 			}
 			x.typ = &Slice{elt: typ.elt}
 
@@ -1239,13 +1281,17 @@
 
 		if !valid {
 			check.invalidOp(x.pos(), "cannot slice %s", x)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		// spec: "Only the first index may be omitted; it defaults to 0."
 		if slice3(e) && (e.High == nil || sliceMax(e) == nil) {
 			check.errorf(e.Rbrack, "2nd and 3rd index required in 3-index slice")
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		// check indices
@@ -1291,21 +1337,29 @@
 	case *ast.TypeAssertExpr:
 		check.expr(x, e.X)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		xtyp, _ := x.typ.Underlying().(*Interface)
 		if xtyp == nil {
 			check.invalidOp(x.pos(), "%s is not an interface", x)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		// x.(type) expressions are handled explicitly in type switches
 		if e.Type == nil {
 			check.invalidAST(e.Pos(), "use of .(type) outside type switch")
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		T := check.typ(e.Type, nil, false)
 		if T == Typ[Invalid] {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		check.typeAssertion(x.pos(), x, xtyp, T)
 		x.mode = commaok
@@ -1318,7 +1372,9 @@
 		check.exprOrType(x, e.X)
 		switch x.mode {
 		case invalid:
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		case typexpr:
 			x.typ = &Pointer{base: x.typ}
 		default:
@@ -1327,18 +1383,24 @@
 				x.typ = typ.base
 			} else {
 				check.invalidOp(x.pos(), "cannot indirect %s", x)
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return statement
 			}
 		}
 
 	case *ast.UnaryExpr:
 		check.expr(x, e.X)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		check.unary(x, e.Op)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		if e.Op == token.ARROW {
 			x.expr = e
@@ -1348,13 +1410,17 @@
 	case *ast.BinaryExpr:
 		check.binary(x, e.X, e.Y, e.Op)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 	case *ast.KeyValueExpr:
 		// key:value expressions are handled in composite literals
 		check.invalidAST(e.Pos(), "no key:value expected")
-		goto Error
+		x.mode = invalid
+		x.expr = e
+		return statement
 
 	case *ast.ArrayType, *ast.StructType, *ast.FuncType,
 		*ast.InterfaceType, *ast.MapType, *ast.ChanType:
@@ -1376,11 +1442,6 @@
 	// everything went well
 	x.expr = e
 	return expression
-
-Error:
-	x.mode = invalid
-	x.expr = e
-	return statement // avoid follow-up errors
 }
 
 // typeAssertion checks that x.(T) is legal; xtyp must be the type of x.
diff -r 181facb811b3 go/types/gcimporter.go
--- a/go/types/gcimporter.go	Fri Oct 11 14:27:44 2013 -0700
+++ b/go/types/gcimporter.go	Sat Oct 12 19:10:17 2013 +0200
@@ -723,7 +723,8 @@
 func (p *gcParser) parseImportDecl() {
 	p.expectKeyword("import")
 	name := p.parsePackageName()
-	p.getPkg(p.parsePackageId(), name)
+	pkg := p.getPkg(p.id, "")
+	pkg.imports = append(pkg.imports, p.getPkg(p.parsePackageId(), name))
 }
 
 // int_lit = [ "+" | "-" ] { "0" ... "9" } .
diff -r 181facb811b3 go/types/methodset.go
--- a/go/types/methodset.go	Fri Oct 11 14:27:44 2013 -0700
+++ b/go/types/methodset.go	Sat Oct 12 19:10:17 2013 +0200
@@ -121,8 +121,8 @@
 		var next []embeddedType // embedded types found at current depth
 
 		// field and method sets at current depth, allocated lazily
-		var fset fieldSet
-		var mset methodSet
+		fset := make(fieldSet)
+		mset := make(methodSet)
 
 		for _, e := range current {
 			// The very first time only, e.typ may be nil.
@@ -229,9 +229,6 @@
 // If multiples is set, f appears multiple times
 // and is treated as a collision.
 func (s fieldSet) add(f *Var, multiples bool) fieldSet {
-	if s == nil {
-		s = make(fieldSet)
-	}
 	key := f.Id()
 	// if f is not in the set, add it
 	if !multiples {
@@ -256,9 +253,6 @@
 	if len(list) == 0 {
 		return s
 	}
-	if s == nil {
-		s = make(methodSet)
-	}
 	for i, f := range list {
 		key := f.Id()
 		// if f is not in the set, add it
diff -r 181facb811b3 go/types/resolver.go
--- a/go/types/resolver.go	Fri Oct 11 14:27:44 2013 -0700
+++ b/go/types/resolver.go	Sat Oct 12 19:10:17 2013 +0200
@@ -316,18 +316,18 @@
 				obj := NewFunc(d.Name.Pos(), pkg, name, nil)
 				if d.Recv == nil {
 					// regular function
-					if name == "init" {
-						// don't declare init functions in the package scope - they are invisible
-						obj.parent = pkg.scope
-						check.recordObject(d.Name, obj)
-						// init functions must have a body
-						if d.Body == nil {
-							check.errorf(obj.pos, "missing function body")
-							// ok to continue
-						}
-					} else {
-						check.declareObj(pkg.scope, d.Name, obj)
-					}
+					// if name == "init" {
+					// 	// don't declare init functions in the package scope - they are invisible
+					// 	obj.parent = pkg.scope
+					// 	check.recordObject(d.Name, obj)
+					// 	// init functions must have a body
+					// 	if d.Body == nil {
+					// 		check.errorf(obj.pos, "missing function body")
+					// 		// ok to continue
+					// 	}
+					// } else {
+					check.declareObj(pkg.scope, d.Name, obj)
+					// }
 				} else {
 					// Associate method with receiver base type name, if possible.
 					// Ignore methods that have an invalid receiver, or a blank _
diff -r 181facb811b3 go/types/sizes.go
--- a/go/types/sizes.go	Fri Oct 11 14:27:44 2013 -0700
+++ b/go/types/sizes.go	Sat Oct 12 19:10:17 2013 +0200
@@ -121,7 +121,7 @@
 
 // DefaultPtrSize is the default size of ints, uint, and pointers, in bytes,
 // used by DefaultSizeof.
-const DefaultPtrSize = 8
+const DefaultPtrSize = 4
 
 // DefaultSizeof implements the default size computation
 // for unsafe.Sizeof. It is used if Config.Sizeof == nil.
diff -r 181facb811b3 go/types/typemap/typemap.go
--- a/go/types/typemap/typemap.go	Fri Oct 11 14:27:44 2013 -0700
+++ b/go/types/typemap/typemap.go	Sat Oct 12 19:10:17 2013 +0200
@@ -130,10 +130,7 @@
 
 // Len returns the number of map entries.
 func (m *M) Len() int {
-	if m != nil {
-		return m.length
-	}
-	return 0
+	return m.length
 }
 
 // Iterate calls function f on each entry in the map in unspecified order.
diff -r 181facb811b3 go/types/types.go
--- a/go/types/types.go	Fri Oct 11 14:27:44 2013 -0700
+++ b/go/types/types.go	Sat Oct 12 19:10:17 2013 +0200
@@ -174,18 +174,12 @@
 
 // NewTuple returns a new tuple for the given variables.
 func NewTuple(x ...*Var) *Tuple {
-	if len(x) > 0 {
-		return &Tuple{x}
-	}
-	return nil
+	return &Tuple{x}
 }
 
 // Len returns the number variables of tuple t.
 func (t *Tuple) Len() int {
-	if t != nil {
-		return len(t.vars)
-	}
-	return 0
+	return len(t.vars)
 }
 
 // At returns the i'th variable of tuple t.
diff -r 181facb811b3 go/types/universe.go
--- a/go/types/universe.go	Fri Oct 11 14:27:44 2013 -0700
+++ b/go/types/universe.go	Sat Oct 12 19:10:17 2013 +0200
@@ -65,7 +65,7 @@
 
 	// Error has a nil package in its qualified name since it is in no package
 	res := NewVar(token.NoPos, nil, "", Typ[String])
-	sig := &Signature{results: NewTuple(res)}
+	sig := &Signature{results: NewTuple(res), params: NewTuple()}
 	err := NewFunc(token.NoPos, nil, "Error", sig)
 	typ := &Named{underlying: &Interface{methods: []*Func{err}}, complete: true}
 	sig.recv = NewVar(token.NoPos, nil, "", typ)
