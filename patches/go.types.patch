diff -r 1d462abd2860 go/types/expr.go
--- a/go/types/expr.go	Wed Oct 09 16:35:59 2013 -0400
+++ b/go/types/expr.go	Wed Oct 09 22:56:42 2013 +0200
@@ -723,9 +723,12 @@
 	}
 
 	if (op == token.QUO || op == token.REM) && y.mode == constant && exact.Sign(y.val) == 0 {
-		check.invalidOp(y.pos(), "division by zero")
-		x.mode = invalid
-		return
+		if !isFloat(x.typ) {
+			check.invalidOp(y.pos(), "division by zero")
+			x.mode = invalid
+			return
+		}
+		x.mode = value
 	}
 
 	if x.mode == constant && y.mode == constant {
@@ -866,7 +869,7 @@
 		typ = Typ[Invalid]
 		record = false // nothing to do
 	case novalue:
-		typ = (*Tuple)(nil)
+		typ = (*Tuple)(NewTuple())
 	case constant:
 		typ = x.typ
 		val = x.val
diff -r 1d462abd2860 go/types/gcimporter.go
--- a/go/types/gcimporter.go	Wed Oct 09 16:35:59 2013 -0400
+++ b/go/types/gcimporter.go	Wed Oct 09 22:56:42 2013 +0200
@@ -723,7 +723,8 @@
 func (p *gcParser) parseImportDecl() {
 	p.expectKeyword("import")
 	name := p.parsePackageName()
-	p.getPkg(p.parsePackageId(), name)
+	pkg := p.getPkg(p.id, "")
+	pkg.imports = append(pkg.imports, p.getPkg(p.parsePackageId(), name))
 }
 
 // int_lit = [ "+" | "-" ] { "0" ... "9" } .
diff -r 1d462abd2860 go/types/methodset.go
--- a/go/types/methodset.go	Wed Oct 09 16:35:59 2013 -0400
+++ b/go/types/methodset.go	Wed Oct 09 22:56:42 2013 +0200
@@ -121,8 +121,8 @@
 		var next []embeddedType // embedded types found at current depth
 
 		// field and method sets at current depth, allocated lazily
-		var fset fieldSet
-		var mset methodSet
+		fset := make(fieldSet)
+		mset := make(methodSet)
 
 		for _, e := range current {
 			// The very first time only, e.typ may be nil.
@@ -229,9 +229,6 @@
 // If multiples is set, f appears multiple times
 // and is treated as a collision.
 func (s fieldSet) add(f *Var, multiples bool) fieldSet {
-	if s == nil {
-		s = make(fieldSet)
-	}
 	key := f.Id()
 	// if f is not in the set, add it
 	if !multiples {
@@ -256,9 +253,6 @@
 	if len(list) == 0 {
 		return s
 	}
-	if s == nil {
-		s = make(methodSet)
-	}
 	for i, f := range list {
 		key := f.Id()
 		// if f is not in the set, add it
diff -r 1d462abd2860 go/types/resolver.go
--- a/go/types/resolver.go	Wed Oct 09 16:35:59 2013 -0400
+++ b/go/types/resolver.go	Wed Oct 09 22:56:42 2013 +0200
@@ -316,18 +316,18 @@
 				obj := NewFunc(d.Name.Pos(), pkg, name, nil)
 				if d.Recv == nil {
 					// regular function
-					if name == "init" {
-						// don't declare init functions in the package scope - they are invisible
-						obj.parent = pkg.scope
-						check.recordObject(d.Name, obj)
-						// init functions must have a body
-						if d.Body == nil {
-							check.errorf(obj.pos, "missing function body")
-							// ok to continue
-						}
-					} else {
-						check.declareObj(pkg.scope, d.Name, obj)
-					}
+					// if name == "init" {
+					// 	// don't declare init functions in the package scope - they are invisible
+					// 	obj.parent = pkg.scope
+					// 	check.recordObject(d.Name, obj)
+					// 	// init functions must have a body
+					// 	if d.Body == nil {
+					// 		check.errorf(obj.pos, "missing function body")
+					// 		// ok to continue
+					// 	}
+					// } else {
+					check.declareObj(pkg.scope, d.Name, obj)
+					// }
 				} else {
 					// Associate method with receiver base type name, if possible.
 					// Ignore methods that have an invalid receiver, or a blank _
diff -r 1d462abd2860 go/types/sizes.go
--- a/go/types/sizes.go	Wed Oct 09 16:35:59 2013 -0400
+++ b/go/types/sizes.go	Wed Oct 09 22:56:42 2013 +0200
@@ -121,7 +121,7 @@
 
 // DefaultPtrSize is the default size of ints, uint, and pointers, in bytes,
 // used by DefaultSizeof.
-const DefaultPtrSize = 8
+const DefaultPtrSize = 4
 
 // DefaultSizeof implements the default size computation
 // for unsafe.Sizeof. It is used if Config.Sizeof == nil.
diff -r 1d462abd2860 go/types/typemap/typemap.go
--- a/go/types/typemap/typemap.go	Wed Oct 09 16:35:59 2013 -0400
+++ b/go/types/typemap/typemap.go	Wed Oct 09 22:56:42 2013 +0200
@@ -130,10 +130,7 @@
 
 // Len returns the number of map entries.
 func (m *M) Len() int {
-	if m != nil {
-		return m.length
-	}
-	return 0
+	return m.length
 }
 
 // Iterate calls function f on each entry in the map in unspecified order.
diff -r 1d462abd2860 go/types/types.go
--- a/go/types/types.go	Wed Oct 09 16:35:59 2013 -0400
+++ b/go/types/types.go	Wed Oct 09 22:56:42 2013 +0200
@@ -174,18 +174,12 @@
 
 // NewTuple returns a new tuple for the given variables.
 func NewTuple(x ...*Var) *Tuple {
-	if len(x) > 0 {
-		return &Tuple{x}
-	}
-	return nil
+	return &Tuple{x}
 }
 
 // Len returns the number variables of tuple t.
 func (t *Tuple) Len() int {
-	if t != nil {
-		return len(t.vars)
-	}
-	return 0
+	return len(t.vars)
 }
 
 // At returns the i'th variable of tuple t.
diff -r 1d462abd2860 go/types/universe.go
--- a/go/types/universe.go	Wed Oct 09 16:35:59 2013 -0400
+++ b/go/types/universe.go	Wed Oct 09 22:56:42 2013 +0200
@@ -65,7 +65,7 @@
 
 	// Error has a nil package in its qualified name since it is in no package
 	res := NewVar(token.NoPos, nil, "", Typ[String])
-	sig := &Signature{results: NewTuple(res)}
+	sig := &Signature{results: NewTuple(res), params: NewTuple()}
 	err := NewFunc(token.NoPos, nil, "Error", sig)
 	typ := &Named{underlying: &Interface{methods: []*Func{err}}, complete: true}
 	sig.recv = NewVar(token.NoPos, nil, "", typ)
